
%%
imSize = [227,227];     % number of [rows, columns] for each samples, in pixels % 227,227
nSamples = 10;      % number of samples for each vernier side in each set
dataType = 'uint8';   % '(u)int8,16,32,64' ; 'logical' ; 'double/single' ; etc.
% D = 1:10;             % various vernier offsets, in pixels
% T = 1:5;              % various vernier thickness, in pixels
% L = 5:12;             % vernier lengths in pixels
D = 1:5;             % various vernier offsets, in pixels
T = 1:3;              % various vernier thickness, in pixels
L = 3:7;             % vernier lengths in pixels
nFlankerPairs = 3;
[RCrowdedTrainSet, RCrowdedTestSet, LCrowdedTrainSet, LCrowdedTestSet] = createUncrowdedSampleSets(imSize,nSamples,D,T,L,dataType,nFlankerPairs);

a = 3;
for i = 1:a^2
    subplot(a,a,i)
    im = repmat(RCrowdedTrainSet(:,:,i)*255,[1,1,3]);
    im_ = single(im) ; % note: 255 range
    im_ = imresize(im_, net.meta.normalization.imageSize(1:2)) ;
    %im_ = im_ - net.meta.normalization.averageImage ;
    imagesc(im_)
    %truesize
end
%truesize
%%
r = randi(min([size(LCrowdedTestSet,3)
    size(LCrowdedTrainSet,3)]));
subplot(1,2,1)
imagesc(LCrowdedTestSet(:,:,r))
subplot(1,2,2)
imagesc(LCrowdedTrainSet(:,:,r))
%truesize

%%
trainSet = 0;
testSet = 0;

epochs = 1;
minibatchSize = 1;
eta = 1;

function myTrain(trainSet,trainAnswers,epochs,batchSize,eta)
dzdy = 0;
for j = 1:epochs
    
    [n, m] = size(trainSet); % n = length(trainAnswers)
    
    shuffling = randperm(n);
    trainAnswers = trainAnswers(shuffling);
    trainSet = trainSet(shuffling);
    
    nMinibatches = floor(n/minibatchSize);
    if nMinibatches == 0
        nMinibatches = 1;
        minibatchSize = n;
    end
    minibatchAnswerses = zeros(minibatchSize,nMinibatches);
    minibatchSets = zeros(minibatchSize,m,nMinibatches);
    for k = 1:nMinibatches
    minibatchAnswerses(:,k) = trainAnswers(k:k + minibatchSize);
    minibatchSets(:,:,k) = trainSet(k:k + minibatchSize,:);
    end
    for k = 1:nMinibatches
        updateMinibatch(minibatchSets(:,:,k),minibatchAnswerses(:,k));
    end
    
end
end

function updateMinibatch(minibatchSet,minibatchAnswers)
    dzdx = vl_nnsoftmax(minibatchSet,minibatchAnswers,dzdy);
end

%%
classifier = struct('layers',[],'meta',[]);
classifier.layers = cell(1);
classifier.layers{1,1} = struct('name','prob','type','softmax','weights',cell(1,2),'precious',0);
classifier.layers{1,1}.weights{1,1}% = [1,2;3,4];

%%
%% Patternet classifier
disp('training patternet classifier');
% create classifier
% Solve a Pattern Recognition Problem with a Neural Network
% Script generated by Neural Pattern Recognition app
% Created 05-Jul-2016 13:12:00
%
% This script assumes these variables are defined:
%
%   DNNTrainSet - input data.
%   DNNTrainAnswers - target data.

x = DNNTrainSet';
t = DNNTrainAnswers';

% Choose a Training Function
% For a list of all training functions type: help nntrain
% 'trainlm' is usually fastest.
% 'trainbr' takes longer but may be better for challenging problems.
% 'trainscg' uses less memory. Suitable in low memory situations.
% trainFcn = 'trainscg';  % Scaled conjugate gradient backpropagation.

% Create a Pattern Recognition Network
hiddenLayerSize = 100;
classifier = patternnet(hiddenLayerSize);


% Setup Division of Data for Training, Validation, Testing
classifier.divideParam.trainRatio = 70/100;
classifier.divideParam.valRatio = 15/100;
classifier.divideParam.testRatio = 15/100;

% Train the Network
[classifier,tr] = train(classifier,x,t);
toc

%% Get prediction
imSize = [50,50];
nSamples = 1;
D = 1:10;
T = 1:5;
L = 5:12;
dataType = 'uint8';
[left, ~, right, ~] = createCrowdedSampleSets(imSize,nSamples,D,T,L,dataType);
r = randi(2);
if r == 1
    stim = left(:,:,1);
else
    stim = right(:,:,1);
end
prediction = getOneClassifierPrediction(stim,net,N,classifier);
figure
imagesc(stim)
title(['prediction: ', num2str(prediction), '. (1 <-> vernier <-> ," )'])

%%
Ns = 21:-1:1;
% Initialize experiment struct
empty = NaN(length(Ns),1);
outcomes = struct('accuracy',empty,...
    'mse',empty);
vernier = struct('train',outcomes,...
    'test',outcomes);
uncrowding = struct('singly',outcomes,...
    'doubly',outcomes,...
    'triply',outcomes);
experiments = struct('vernier',vernier,...
    'crowding',outcomes,...
    'uncrowding',uncrowding,...
    'layers',Ns');


ks = ce

